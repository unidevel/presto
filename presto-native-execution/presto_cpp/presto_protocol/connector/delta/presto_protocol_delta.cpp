// DO NOT EDIT : This file is generated by chevron
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// presto_protocol.prolog.cpp
//

// This file is generated DO NOT EDIT @generated

#include "presto_cpp/presto_protocol/connector/delta/presto_protocol_delta.h"
using namespace std::string_literals;

namespace facebook::presto::protocol::delta {

void to_json(json& j, const DeltaTransactionHandle& p) {
  j = json::array();
  j.push_back(p._type);
  j.push_back(p.instance);
}

void from_json(const json& j, DeltaTransactionHandle& p) {
  j[0].get_to(p._type);
  j[1].get_to(p.instance);
}
} // namespace facebook::presto::protocol::delta
namespace facebook::presto::protocol::delta {

void to_json(json& j, const DeltaColumn& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "DeltaColumn", "String", "name");
  to_json_key(j, "type", p.type, "DeltaColumn", "TypeSignature", "type");
  to_json_key(j, "nullable", p.nullable, "DeltaColumn", "bool", "nullable");
  to_json_key(j, "partition", p.partition, "DeltaColumn", "bool", "partition");
}

void from_json(const json& j, DeltaColumn& p) {
  from_json_key(j, "name", p.name, "DeltaColumn", "String", "name");
  from_json_key(j, "type", p.type, "DeltaColumn", "TypeSignature", "type");
  from_json_key(j, "nullable", p.nullable, "DeltaColumn", "bool", "nullable");
  from_json_key(
      j, "partition", p.partition, "DeltaColumn", "bool", "partition");
}
} // namespace facebook::presto::protocol::delta
namespace facebook::presto::protocol::delta {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ColumnType, json> ColumnType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {ColumnType::REGULAR, "REGULAR"},
        {ColumnType::PARTITION, "PARTITION"},
        {ColumnType::SUBFIELD, "SUBFIELD"}};
void to_json(json& j, const ColumnType& e) {
  static_assert(std::is_enum<ColumnType>::value, "ColumnType must be an enum!");
  const auto* it = std::find_if(
      std::begin(ColumnType_enum_table),
      std::end(ColumnType_enum_table),
      [e](const std::pair<ColumnType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ColumnType_enum_table))
           ? it
           : std::begin(ColumnType_enum_table))
          ->second;
}
void from_json(const json& j, ColumnType& e) {
  static_assert(std::is_enum<ColumnType>::value, "ColumnType must be an enum!");
  const auto* it = std::find_if(
      std::begin(ColumnType_enum_table),
      std::end(ColumnType_enum_table),
      [&j](const std::pair<ColumnType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ColumnType_enum_table))
           ? it
           : std::begin(ColumnType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::delta
namespace facebook::presto::protocol::delta {
DeltaColumnHandle::DeltaColumnHandle() noexcept {
  _type = "hive-delta";
}

void to_json(json& j, const DeltaColumnHandle& p) {
  j = json::object();
  j["@type"] = "hive-delta";
  to_json_key(j, "columnName", p.name, "DeltaColumnHandle", "String", "name");
  to_json_key(
      j,
      "dataType",
      p.dataType,
      "DeltaColumnHandle",
      "TypeSignature",
      "dataType");
  to_json_key(
      j,
      "columnType",
      p.columnType,
      "DeltaColumnHandle",
      "ColumnType",
      "columnType");
  to_json_key(
      j, "subfield", p.subfield, "DeltaColumnHandle", "Subfield", "subfield");
}

void from_json(const json& j, DeltaColumnHandle& p) {
  p._type = j["@type"];
  from_json_key(j, "columnName", p.name, "DeltaColumnHandle", "String", "name");
  from_json_key(
      j,
      "dataType",
      p.dataType,
      "DeltaColumnHandle",
      "TypeSignature",
      "dataType");
  from_json_key(
      j,
      "columnType",
      p.columnType,
      "DeltaColumnHandle",
      "ColumnType",
      "columnType");
  from_json_key(
      j, "subfield", p.subfield, "DeltaColumnHandle", "Subfield", "subfield");
}
} // namespace facebook::presto::protocol::delta
namespace facebook::presto::protocol::delta {
DeltaSplit::DeltaSplit() noexcept {
  _type = "hive-delta";
}

void to_json(json& j, const DeltaSplit& p) {
  j = json::object();
  j["@type"] = "hive-delta";
  to_json_key(
      j, "connectorId", p.connectorId, "DeltaSplit", "String", "connectorId");
  to_json_key(
      j, "schemaName", p.schemaName, "DeltaSplit", "String", "schemaName");
  to_json_key(j, "tableName", p.tableName, "DeltaSplit", "String", "tableName");
  to_json_key(
      j,
      "tableLocation",
      p.tableLocation,
      "DeltaSplit",
      "String",
      "tableLocation");
  to_json_key(j, "filePath", p.filePath, "DeltaSplit", "String", "filePath");
  to_json_key(j, "start", p.start, "DeltaSplit", "int64_t", "start");
  to_json_key(j, "length", p.length, "DeltaSplit", "int64_t", "length");
  to_json_key(j, "fileSize", p.fileSize, "DeltaSplit", "int64_t", "fileSize");
  to_json_key(
      j,
      "partitionValues",
      p.partitionValues,
      "DeltaSplit",
      "Map<String, String>",
      "partitionValues");
}

void from_json(const json& j, DeltaSplit& p) {
  p._type = j["@type"];
  from_json_key(
      j, "connectorId", p.connectorId, "DeltaSplit", "String", "connectorId");
  from_json_key(
      j, "schemaName", p.schemaName, "DeltaSplit", "String", "schemaName");
  from_json_key(
      j, "tableName", p.tableName, "DeltaSplit", "String", "tableName");
  from_json_key(
      j,
      "tableLocation",
      p.tableLocation,
      "DeltaSplit",
      "String",
      "tableLocation");
  from_json_key(j, "filePath", p.filePath, "DeltaSplit", "String", "filePath");
  from_json_key(j, "start", p.start, "DeltaSplit", "int64_t", "start");
  from_json_key(j, "length", p.length, "DeltaSplit", "int64_t", "length");
  from_json_key(j, "fileSize", p.fileSize, "DeltaSplit", "int64_t", "fileSize");
  from_json_key(
      j,
      "partitionValues",
      p.partitionValues,
      "DeltaSplit",
      "Map<String, String>",
      "partitionValues");
}
} // namespace facebook::presto::protocol::delta
namespace facebook::presto::protocol::delta {

void to_json(json& j, const DeltaTable& p) {
  j = json::object();
  to_json_key(
      j, "schemaName", p.schemaName, "DeltaTable", "String", "schemaName");
  to_json_key(j, "tableName", p.tableName, "DeltaTable", "String", "tableName");
  to_json_key(
      j,
      "tableLocation",
      p.tableLocation,
      "DeltaTable",
      "String",
      "tableLocation");
  to_json_key(
      j, "snapshotId", p.snapshotId, "DeltaTable", "Long", "snapshotId");
  to_json_key(
      j, "columns", p.columns, "DeltaTable", "List<DeltaColumn>", "columns");
}

void from_json(const json& j, DeltaTable& p) {
  from_json_key(
      j, "schemaName", p.schemaName, "DeltaTable", "String", "schemaName");
  from_json_key(
      j, "tableName", p.tableName, "DeltaTable", "String", "tableName");
  from_json_key(
      j,
      "tableLocation",
      p.tableLocation,
      "DeltaTable",
      "String",
      "tableLocation");
  from_json_key(
      j, "snapshotId", p.snapshotId, "DeltaTable", "Long", "snapshotId");
  from_json_key(
      j, "columns", p.columns, "DeltaTable", "List<DeltaColumn>", "columns");
}
} // namespace facebook::presto::protocol::delta
namespace facebook::presto::protocol::delta {
DeltaTableHandle::DeltaTableHandle() noexcept {
  _type = "hive-delta";
}

void to_json(json& j, const DeltaTableHandle& p) {
  j = json::object();
  j["@type"] = "hive-delta";
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "DeltaTableHandle",
      "String",
      "connectorId");
  to_json_key(
      j,
      "deltaTable",
      p.deltaTable,
      "DeltaTableHandle",
      "DeltaTable",
      "deltaTable");
}

void from_json(const json& j, DeltaTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "DeltaTableHandle",
      "String",
      "connectorId");
  from_json_key(
      j,
      "deltaTable",
      p.deltaTable,
      "DeltaTableHandle",
      "DeltaTable",
      "deltaTable");
}
} // namespace facebook::presto::protocol::delta
namespace facebook::presto::protocol::delta {
DeltaTableLayoutHandle::DeltaTableLayoutHandle() noexcept {
  _type = "hive-delta";
}

void to_json(json& j, const DeltaTableLayoutHandle& p) {
  j = json::object();
  j["@type"] = "hive-delta";
  to_json_key(
      j,
      "table",
      p.table,
      "DeltaTableLayoutHandle",
      "DeltaTableHandle",
      "table");
  to_json_key(
      j,
      "predicate",
      p.predicate,
      "DeltaTableLayoutHandle",
      "TupleDomain<DeltaColumnHandle>",
      "predicate");
  to_json_key(
      j,
      "predicateText",
      p.predicateText,
      "DeltaTableLayoutHandle",
      "String",
      "predicateText");
}

void from_json(const json& j, DeltaTableLayoutHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "table",
      p.table,
      "DeltaTableLayoutHandle",
      "DeltaTableHandle",
      "table");
  from_json_key(
      j,
      "predicate",
      p.predicate,
      "DeltaTableLayoutHandle",
      "TupleDomain<DeltaColumnHandle>",
      "predicate");
  from_json_key(
      j,
      "predicateText",
      p.predicateText,
      "DeltaTableLayoutHandle",
      "String",
      "predicateText");
}
} // namespace facebook::presto::protocol::delta
